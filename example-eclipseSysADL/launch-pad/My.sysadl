Model SysADLModel ; package BaseTorque.Connectors { import BaseTorque.SystemPorts ; connector def BotaoCancelarCN { participants : ~ source : BotaoCancelarOPT ; ~ destination : BotaoCancelarIPT ; flows : Command from source to destination connector def newElement { } } connector def ValvulaStatusCN { participants : ~ souce : ValvulaStatusOPT ; ~ destination : ValvulaStatusIPT ; flows : CommandValvula from souce to destination } connector def AberturaValvulaCN { participants : ~ destination : AberturaValvulaIPT ; ~ source : AberturaValvulaOPT ; flows : TempoAtivacao from source to destination } connector def AtivarMotorCN { participants : ~ destination : AtivarMotorIPT ; ~ source : AtivarMotorOPT ; flows : TempoAtivacao from source to destination } connector def MotorStatusCN { participants : ~ destination : MotorStatusIPT ; ~ source : MotorStatusOPT ; flows : Command from source to destination } connector def BotaoMotorCN { participants : ~ destination : BotaoMotorIPT ; ~ source : BotaoMotorOPT ; flows : Command from source to destination } connector def BotaoValvulaCN { participants : ~ destination : BotaoValvulaIPT ; ~ source : BotaoValvulaOPT ; flows : Command from source to destination } } package BaseTorque.Components { import BaseTorque.SystemPorts ; import BaseTorque.types ; import BaseTorque.Connectors ;
	component def BaseTorqueSystem {  configuration { components :       BaseTorqueControllerCP : BaseTorqueControllerCP { using ports : timeOut : AberturaValvulaOPT ; timeOut : AtivarMotorOPT ; status : BotaoCancelarIPT ; status : BotaoMotorIPT ; status : BotaoValvulaIPT ; status : ValvulaStatusOPT ; timeIn : AberturaValvulaIPT ; status : MotorStatusOPT ; timeIn : AtivarMotorIPT ; } BotaoCancelarCP : BotaoCancelarCP { using ports : botaoUser : BotaoCancelarOPT ; } BotaoMotorCP : BotaoMotorCP { using ports : botaoMUser : BotaoMotorOPT ; } BotaoValvulaCP : BotaoValvulaCP { using ports : botaoVUser : BotaoValvulaOPT ; } MotorCP : MotorCP { using ports : componentUser : MotorStatusIPT ; } ValvulaCP : ValvulaCP { using ports : componentVUser : ValvulaStatusIPT ; } connectors :                    vs : ValvulaStatusCN bindings status = componentVUser ; ms : MotorStatusCN bindings status = componentUser ; am : AtivarMotorCN bindings timeOut = timeIn ; av : AberturaValvulaCN bindings timeOut = timeIn ; bm : BotaoMotorCN bindings botaoMUser = status ; bc : BotaoCancelarCN bindings botaoUser = status ; bv : BotaoValvulaCN bindings botaoVUser = status ; } }
	component def ValvulaCP { ports : componentVUser : ValvulaStatusIPT ; }
	component def MotorCP { ports : componentUser : MotorStatusIPT ; }
	component def BotaoMotorCP { ports : buttonMUser : BotaoMotorOPT ; }
	component def BotaoValvulaCP { ports : buttonVUser : BotaoValvulaOPT ; }
	component def BotaoCancelarCP { ports : buttonUser : BotaoCancelarOPT ; }
	component def BaseTorqueControllerCP { ports : timeOut : AberturaValvulaOPT ; timeOut : AtivarMotorOPT ; status : BotaoCancelarIPT ; status : BotaoMotorIPT ; status : BotaoValvulaIPT ; status : ValvulaStatusOPT ; timeIn : AberturaValvulaIPT ; status : MotorStatusOPT ; timeIn : AtivarMotorIPT ; }  activity def AcionamentoMotorAC ( acionarMotorIPT : Command ) ( tempoAtivacao : TempoAtivacao ) : ( acionarMotorOPT : Command ) { body { actions : AberturaMotorAN : RotacionarMotorAN { using pins : tempoAtivacao : TempoAtivacao ; acionarMotorIPT : Command ; } delegate tempoAtivacao to tempoAtivacao delegate acionarMotorIPT to acionarMotorIPT delegate acionarMotorOPT to AberturaMotorAN } }  action def AcionarMotorAN ( bAcionarValvula : Command , bAcionarMotor : Command , bCancelar : Command ) : Command { constraint : post-condition DecidirAcionamentoEQ post-condition CancelarAcionamentoEQ delegate AcionarMotorAN to ativarMotor delegate bAcionarValvula to bAcionarMotor delegate bAcionarMotor to bAcionarValvula delegate bCancelar to bCancelar delegate AcionarMotorAN to desligarMotor } constraint DecidirAcionamentoEQ ( bAcionarValvula : Command , bAcionarMotor : Command ) : ( ativarMotor : Command , abrirValvula : CommandValvula ) { equation = (bAcionarMotor== Command::On && bAcionarValvula == Command::Off)? ativarMotor == Command::On : (bAcionarMotor== Command::Off && bAcionarValvula == Command::On)? abrirValvula == Command::On : (abrirValvula == Command::Off && ativarMotor == Command::On ) } constraint CancelarAcionamentoEQ ( bCancelar : Command ) : ( desligarMotor : Command , fecharValvula : CommandValvula ) { equation = (bCancelar == Command::On) ? (desligarMotor == Command::Off && fecharValvula == Command::Off) : (null) } activity def ControleAcionamentoAC ( bAcionarValvula : Command ) ( bAcionarMotor : Command ) ( bCancelar : Command ) : ( acionarMotor : Command , acionarValvula : CommandValvula ) { body { actions : AcionarMotorAN : AcionarMotorAN { using pins : bAcionarValvula : Command ; bAcionarMotor : Command ; bCancelar : Command ; } AcionarValvulaAN : AcionarValvulaAN { using pins : btAcionarValvula : Command ; btAcionarMotor : Command ; btCancelar : Command ; } delegate bAcionarMotor to bAcionarMotor delegate bAcionarValvula to bAcionarValvula delegate acionarMotor to AcionarMotorAN delegate bCancelar to bCancelar delegate acionarValvula to AcionarValvulaAN delegate bCancelar to btCancelar delegate bAcionarMotor to btAcionarMotor delegate bAcionarValvula to btAcionarValvula } } action def AcionarValvulaAN ( btAcionarValvula : Command , btAcionarMotor : Command , btCancelar : Command ) : CommandValvula { constraint : post-condition CancelarAcionamentoEQ post-condition DecidirAcionamentoEQ delegate AcionarValvulaAN to fecharValvula delegate AcionarValvulaAN to abrirValvula delegate btCancelar to bCancelar delegate btAcionarMotor to bAcionarMotor delegate btAcionarValvula to bAcionarValvula } action def AberturaValvulaAN ( tempoAtivacao1 : TempoAtivacao , tempoAtivacao2 : TempoAtivacao , tempoAtivacao3 : TempoAtivacao , acionarValvulaIPT : CommandValvula , ativacaoCorrente : int ) : CommandValvula { constraint : post-condition TempoAcionamentoValvulaEQ delegate tempoAtivacao1 to tempoAtivacao1 delegate tempoAtivacao2 to tempoAtivacao2 delegate tempoAtivacao3 to tempoAtivacao3 delegate AberturaValvulaAN to acionarValvulaOPT delegate acionarValvulaIPT to acionarValvulaIPT delegate ativacaoCorrente to ativacaoCorrente } constraint TempoAcionamentoValvulaEQ ( tempoAtivacao1 : TempoAtivacao , tempoAtivacao2 : TempoAtivacao , tempoAtivacao3 : TempoAtivacao , acionarValvulaIPT : CommandValvula , ativacaoCorrente : int ) : ( acionarValvulaOPT : CommandValvula ) { equation = (acionarValvulaIPT == Command::On && tempoAtivacao1 > 0 && ativacaoCorrente == 1 ) ? (acionarValvulaOPT == Command::On && tempoAtivacao1 == tempoAtivacao1 - 1) : (acionarValvulaIPT == Command::On && tempoAtivacao2 > 0 && ativacaoCorrente == 2 ) ? ( acionarValvulaOPT == Command::On && tempoAtivacao2 == tempoAtivacao2 - 1) : (acionarValvulaIPT == Command::On && tempoAtivacao3 > 0 && ativacaoCorrente == 3 ) ? (acionarValvulaOPT == Command::On && tempoAtivacao3 == tempoAtivacao3 - 1) : acionarValvulaOPT == Command::Off } action def RotacionarMotorAN ( tempoAtivacao : TempoAtivacao , acionarMotorIPT : Command ) : Command { constraint : post-condition TempoAcionamentoMotorEQ delegate tempoAtivacao to tempoAtivacao delegate RotacionarMotorAN to acionarMotorOPT delegate acionarMotorIPT to acionarMotorIPT } constraint TempoAcionamentoMotorEQ ( tempoAtivacao : TempoAtivacao , acionarMotorIPT : Command ) : ( acionarMotorOPT : Command ) { equation = (acionarMotorIPT == Command::On && tempoAtivacao > 0) ?(acionarMotorOPT == Command::On && tempoAtivacao == tempoAtivacao - 1) : acionarMotorOPT == Command::Off } activity def AberturaValvulaAC ( acionarValvulaIPT : CommandValvula ) ( tempoAtivacao1 : TempoAtivacao ) ( tempoAtivacao2 : TempoAtivacao ) ( tempoAtivacao3 : TempoAtivacao ) ( ativacaoCorrente : int ) : ( acionarValvulaOPT : CommandValvula ) { body { actions : AberturaValvulaAN : AberturaValvulaAN { using pins : tempoAtivacao1 : TempoAtivacao ; tempoAtivacao2 : TempoAtivacao ; tempoAtivacao3 : TempoAtivacao ; acionarValvulaIPT : CommandValvula ; ativacaoCorrente : int ; } delegate ativacaoCorrente to ativacaoCorrente delegate tempoAtivacao1 to tempoAtivacao1 delegate tempoAtivacao2 to tempoAtivacao2 delegate tempoAtivacao3 to tempoAtivacao3 delegate acionarValvulaIPT to acionarValvulaIPT delegate acionarValvulaOPT to AberturaValvulaAN } } } package BaseTorque.SystemPorts { import BaseTorque.types ; port def AberturaValvulaOPT { flow out TempoAtivacao } port def ValvulaStatusIPT { flow in CommandValvula } port def MotorStatusIPT { flow in Command } port def BotaoValvulaOPT { flow out Command } port def BotaoMotorOPT { flow out Command } port def AtivarMotorOPT { flow out TempoAtivacao } port def BotaoCancelarOPT { flow out Command } port def ValvulaStatusOPT { flow out CommandValvula } port def MotorStatusOPT { flow out Command } port def BotaoCancelarIPT { flow in Command } port def BotaoValvulaIPT { flow in Command } port def BotaoMotorIPT { flow in Command } port def AtivarMotorIPT { flow in TempoAtivacao } port def AberturaValvulaIPT { flow in TempoAtivacao } } package BaseTorque.types { value type int { } dimension Tempo   value type TempoAtivacao { unit = Segundos dimension = Tempo } unit Segundos { dimension = Tempo } enum CommandValvula { Open , Close } enum Command { On , Off } datatype Commands { attributes : Valvula : CommandValvula ; Motor : Command ; Botao : Command ; } } Requirement ControleAcionamentoFR ( 1 ) { text = "O controle deve ser apto a decidir qual componente acionar e também a cancelar o acionamento." satisfied by BaseTorque.Components.BaseTorqueControllerCP ; Requirement VerificarBotaoValvulaFR ( 1.1 ) { text = "O controle deve detectar quando o botão da válvula for acionado e garantir apenas a válvula seja ativada." satisfied by BaseTorque.Components.BotaoValvulaCP ; } Requirement VerificarBotaoMotorFR ( 1.2 ) { text = "O controle deve detectar quando o botão do motor for acionado e garantir apenas o motor seja ativado." satisfied by BaseTorque.Components.BotaoMotorCP ; } Requirement VerificarBotaoCancelarFR ( 1.3 ) { text = "O controle deve detectar quando o botão de cancelar for acionado e garantir que os componentes estejam desativados." satisfied by BaseTorque.Components.BotaoCancelarCP ; } } Requirement AcionarMotorFR ( 1.5 ) { text = "Acionar o motor por 0,2 segundos caso o botão de lançamento seja acionado." satisfied by BaseTorque.Components.MotorCP ; derive ControleAcionamentoFR.VerificarBotaoMotorFR ; } Requirement AcionarValvulaFR ( 1.4 ) { text = "Acionar a válvula solenóide por 20 segundos caso o botão de  abastecimento seja acionado na primeira vez, 32 segundos na segunda e 40 segundos na terceira." satisfied by BaseTorque.Components.ValvulaCP ; derive ControleAcionamentoFR.VerificarBotaoValvulaFR ; } Requirement QualidadeNFR ( 2 ) { text = "O sistema deve atender os requisitos de qualidade: modificabilidade, escalabilidade, disponibilidade e acurácia." Requirement AcuraciaNFR ( 2.4 ) { text = "O sistema deve ativar os componentes exatamente no tempo especificado nos requisitos funcionais." } Requirement ModificabilidadeNFR ( 2.1 ) { text = "O sistema deve permitir a adição de novas funcionalidades com facilidade." } Requirement EscalabilidadeNFR ( 2.2 ) { text = "O sistema deve ser escalável para permitir a inserção de novos componentes eletrônicos para controle de novas bases de lançamento." } Requirement DisponibilidadeNFR ( 2.3 ) { text = "O sistema deve estar disponível para operação enquanto estiver conectado a uma fonte de energia." } }